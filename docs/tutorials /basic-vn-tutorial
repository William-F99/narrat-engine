We’re going to make a tiny visual novel that uses a variety of design patterns you will find useful in your own work. I recommend playing the finished product [here] before following this tutorial so you have a frame of reference.

Right out of the box, you’ll see the three main visual components of a Narrat game: the background, the dialog panel, and the character portrait.

The dialog panel displays the game’s prose, the dialog of the various characters, the player’s dialog options, and the continue button.

We’ll begin immediately after you install Narrat. For installation instructions, click [here]. At the end of the installation process, choose the demo option, not blank project. It will make your life significantly easier.

Let’s start with a quick overview of a Narrat project. There are two main folders that contain the significant parts of your game: src and public.

You can ignore pretty much all the other folders and files. Public contains all your assets: audio, images, music, etc. Poke around there now, and you’ll see all the assets associated with the demo project. 

Src contains all the code and text of your visual novel, the CSS you will use to customize the game’s look, and the config, which is like a directory that tells Narrat where to find your game’s assets and what to do with them.

We’re going to spend a little time before we jump in learning how to set up our own project.

Navigate to src>config>common.yaml.

Here, you can fiddle with some of the basic formatting of your Narrat game. Feel free to experiment with what looks good to you in the demo project. If you break something, you can always start over.

Check out your changes by navigating to your project’s root folder, shift-right-clicking to get access to the ‘Open PowerShell Window’ option, typing ‘npm start’, and copy-pasting the local host into your preferred browser.

These are the settings I’ll be using.

While we’re here, let’s delete the energy stat, just leaving the money stat.
	
Changing the name is optional, but setting the startingValue to 200 will be important later.

The demo project comes with some images we don’t need. We’ll use the images found [here], so that you can practice setting up a project with your own assets. 

Delete all the files found in public>img>backgrounds, public>music, and public>img>characters. We won’t worry about the skills, items, or UI in this tutorial. Bring the files from the above link into the corresponding folders in your project. 

Now, we have to tell Narrat where these files are so that we can actually use and reference them. Go to src>config>screens.yaml. Currently, the code here is still trying to refer to those demo images we deleted. We’ll copy the formatting for that as we put in the new file paths.

Repeat this process for audio.yaml.

We’ll be using the Narrat’s default sfx, so keep the others there.

And again for characters.yaml. However, here we get more customization options. You can choose a character’s display name, the display name color, and more. For the player, change the portrait to none.

Now, we’re going to build the game piece by piece, learning how Narrat works in the process. Without further ado, let’s open up demo.narrat in src>scripts.

Delete all the code that comes with the demo. We don’t need it!

At the very top, put the following:

main: is a label, which is one of the building blocks of a Narrat codebase. A label runs everything inside it, line by line, until it runs out of things to run.

When you start a new game, your game will begin running the main label.

Mostly, a label will contain text. You can display text in the dialog panel by just putting that text in quotation marks. Think of quotation marks as telling Narrat “Hey, show this text to the player.”

Each line of text in the label will be separated by the Continue button.

If we playtest the game, we see a black screen and the two lines of text we wrote show up. After that, there’s nothing else for the game to run. And hey, there’s our two hundred dollars!

Besides text, a Narrat label handles ‘Commands,’ another key component of Narrat games. Commands help you handle choices, text, sprites, sound, and all the other things you need to make a video game.

Let’s change our ‘main:’ label to have some actual content, and make use of a command.
 
Our set up has paid off! With just one quick command, we’re able to set the scene for our player.

The set_screen command is looking at our screens.yaml, finding the one called harbor, and pulling that image from the spot we’ve directed it to. We can now flip between the screens we’ve set up with ease.

You may have realized this already, but that black screen that appeared earlier was not random: it was the ‘default’ screen we set up. Narrat automatically displays the default screen if no screen is set.

We’ve got a setting, now we need dialogue. Let’s make use of the talk command.	

While the set_screen command takes only one argument (the name of the screen), the talk command takes two: the name of the character and the name of the sprite.

If you recall our characters.yaml file, you’ll remember that we put our image under ‘idle.’ If we had more images to use, we could put another under ‘angry’ and use that when our character is mad. All characters must have an idle sprite, and we only have one image for our characters, so that’s what we’ll be using.

And there he is! What a charming young man. Notice how Narrat automatically adds quotation marks.

What if we want the portrait to appear without quotation marks? Well, to do that, we’ll use the ‘think’ command.

Think works just like talk, but it does not add quotation marks.

Hmm, but why is it a different color? Well, by default, Narrat uses a different text color for the think command, but we can change that with a tiny bit of CSS.

In main.css, add this bit of code.

This sets the color associated with the think command to match whatever your default text color is. If you change your text color in the pre-filled field in main.css, it will also change the think command’s color.

Now, if you want to use a dialog tag, like “Francis said, wringing his hands,” we do that with the think command as well.

Since the think command does not add quotation marks on its own, you have to add them manually with \”, allowing you to put little actions beside your dialog. The backslash tells Narrat to put the ensuing quotation mark in the dialog, rather than interpreting it as a request to display text.

Now we’re cooking! It’s time we added choices to our game. Let’s see an example first.

This is the simplest use of the choice function. It does not branch the narrative, just lets the player see different content depending on what they choose, then the story continues unaffected. Note the indentation levels and the colons, both essential to properly format this command.

The first bit of text, the choice prompt, can take a ‘talk’ or ‘think’ command as can the responses, but the dialog options that end with a colon cannot.

If you would like these options to be presented with quotation marks, as if the player character is saying them you can add them in using \” as before.

Let’s put some real content in here!

We’ve created a good introductory section of the game. Let’s move to another label to continue our work.

To do so, we use the ‘jump’ command and pass the name of the new label as an argument.

Simple! Now Narrat will continue from this label, running line-by-line as before.

These simple commands (talk, think, choice, and jump) will form the foundation of your visual novel, but, with an understanding of a few more common features and design patterns, you can effectively scale up your game’s complexity and reactivity.

First, what if we want the game to remember a player’s choice? We can do that easily with variables.

Here, we used the ‘set’ command to store a boolean value in a variable called willingToBetray. When setting a variable in Narrat, we have to tell the engine where that variable will be stored, so that it can find it later.

You’ve probably noticed the stat in the top right corner of our image. This is a stat, which functions similarly to a variable. We can use it to see how Narrat handles numbers.

It’s dead simple. We’re using the add_stat command, which tells Narrat “Add the following amount to the stat ‘money’,” then we add negative one hundred in order to perform a subtraction operation.

We put the command before the dialog where we hand it over because when the player clicks continue on Isaac’s line, it will run the command, then display the text, making it seem like they happened at the same time.
Now, we’re going to spend the rest of the tutorial learning how to reference these variables in ways to give our game more reactivity.

Everything here should look familiar except for that ‘if’ statement. Let’s see how it works.

Immediately after the ‘if’ you must put parentheses around your condition. The if statement simply checks if the condition returns a true value. If it does, it will show the indented text. If not, it will skip it and move onto the next line.

First in our condition, we have the == command. This command essentially says “Check if the following two arguments are true. If they are, return true. If not, return false.” Your condition must contain a command that returns a true or false value.

Next, we pass our variable in as an argument. Since we are not changing the variable, we do not use the data. prefix. Instead, we put a $ to tell Narrat to go find that variable and tell us its value.

Again, you use data.variable when setting or changing the variable. You use $variable when you want to access or check the value stored in the variable.

Finally, we have the boolean value of true: that’s what we’re comparing our variable against.

Stepping through our if statement, it should be relatively simple. If the player said they were willing to betray Francis, our condition will return true, and the game displays this line about the player character having doubts. If they are not willing to betray him, our condition returns false, and this line will get skipped.

Let’s now combine the if statement with the choice function to get some really fun stuff going.

The if statement functions as before, but now the result is that it will only display the choice itself if the condition returns as true. No matter what, only one choice will appear here, as a variable cannot be both true and false at the same time.

Let’s move onto learning how to make a dialog tree, which will combine all of the things we’ve learned.

First, we’ll bridge the gap between our current scene and the dialog tree.

Let’s break this down piece by piece.

The first thing to notice about these choices is that they result in the player jumping to a label. By jumping back to the top of the label we’re in, we can let the player select from the same collection of choices again. It’s important that the label starts with the choice function, otherwise the player will have to click through any preceding text every time. Also, the prompt text will appear each time, so it should be neutral enough that it makes sense for it to reappear.

Narrat automatically tracks if a choice has been selected and will gray it out if so. However, it is still selectable. If you don’t want the player to be able to click through that option more than once, you’ll have to add a condition like we’ve done in the second label.

Speaking of, let’s break down that if statement. It’s a little different from our previous ones.

First, our operator is different. This is the ‘less than’ operator. It’s telling Narrat, “Check if the first argument is less than the second, if it is, return true. Otherwise, return false.”

Since our skill is not stored in a typical variable, we have to put parentheses around another operation to tell Narrat to take care of that before it attempts to figure out the rest of the condition.

The ‘get_stat_value’ command does exactly what it sounds like: it returns the value inside the stat we tell it to check. In this case, that’s money. We know that this will return 100 when the player opens this dialog tree.

On opening these choices, Narrat will find the current value of the player’s money, then it will check if the player’s money (100) is less than 150. That will return true, and the option will be present. Once that choice is selected, Philip adds 50 to the player’s money, making it 150. 150 is equal to, not less than, 150, so the option will disappear, preventing the player from adding 50 money an infinite number of times.

With a combination of ‘choice’, ‘jump’, and ‘if’, it’s easy to imagine creating a massive dialog tree composed of smaller dialog trees with options that change based on other responses the player has given.

Certainly that’s enough to get you started in Narrat! As for what to do next, here’s a few ideas: play one of the music tracks, change the font and font color, or add animation to the screen transitions, and, of course, export and upload your game!

Best of luck and have fun!
